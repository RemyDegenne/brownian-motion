import Mathlib


open MeasureTheory Filter Finset Set Function TopologicalSpace Topology

open scoped ENNReal NNReal

variable {Î¹ Î± Î© E : Type*}

variable [TopologicalSpace Î¹] [hÎ± : TopologicalSpace Î±] [ConditionallyCompleteLattice Î±]
  [ClosedIicTopology Î±] {f : Î¹ â†’ Î±} {S : Set Î¹}

theorem continuous_supremum_dense (hS : Dense S) (hf : Continuous f)
    (h : BddAbove (range f)) :
    â¨† i, f i = â¨† s : S, f s := by
  rw [â† sSup_range, â† sSup_range]
  obtain (_ | _) := isEmpty_or_nonempty Î¹
  Â· simp [Set.range_eq_empty]
  have hâ‚‚ : Nonempty S := hS.nonempty.to_subtype
  refine (isLUB_csSup (range_nonempty f) h).unique ?_
  rw [â† isLUB_iff_of_subset_of_subset_closure (image_subset_range f S)
    (hf.range_subset_closure_image_dense hS)]
  simpa [â† Function.comp_def, range_comp] using
    isLUB_csSup (range_nonempty (fun x : S â†¦ f x)) <| h.mono <| range_comp_subset_range ..

variable [PartialOrder Î¹] [OrderTopology Î¹]

/- Aristotle failed to find a proof. -/
/- Let S be a dense subset of Î¹ in the usual order topology. Suppose it contains all isolated
points on the right. Then S is dense in the lower limit topology (the topology generated by
Set.Ico i j). -/
theorem dense_of_dense (hS : Dense S) (hi : {x | ğ“[>] x = âŠ¥} âŠ† S) :
    @Dense Î¹ (TopologicalSpace.generateFrom {s : Set Î¹ | âˆƒ i j, s = Set.Ico i j}) S := by
  sorry

/- If f is right continuous, then f is continuous with respect to the lower limit topology. -/
noncomputable section AristotleLemmas

#print OrderTopology
#print Set.Ico
#check NoMaxOrder

/-
Assume Î¹ has no maximum element, which is necessary for the lower limit topology to behave as expected (otherwise the max element is isolated in a way that breaks continuity).
-/
variable [NoMaxOrder Î¹]

theorem nhds_lowerLimit_eq (a : Î¹) :
    @nhds Î¹ (TopologicalSpace.generateFrom {s | âˆƒ i j, s = Set.Ico i j}) a =
    â¨… b > a, ğ“Ÿ (Set.Ico a b) := by
      by_contra h_not_eq;
      -- Since any interval [i, j) containing a must have i â‰¤ a and j > a, the infimum over all such intervals is the same as the infimum over the intervals [a, b) where b > a.
      have h_inf_eq : â¨… (i : Î¹), â¨… (j : Î¹), â¨… (_ : i â‰¤ a âˆ§ a < j), ğ“Ÿ (Set.Ico i j) = â¨… (b : Î¹), â¨… (_ : b > a), ğ“Ÿ (Set.Ico a b) := by
        refine' le_antisymm _ _;
        Â· refine' le_iInf fun b => le_iInf fun hb => _;
          refine' le_trans ( iInf_le _ a ) _;
          refine' le_trans ( iInf_le _ b ) _;
          simp +decide [ hb ];
        Â· simp +decide [ iInf_le_iff ];
          intro i j hi hj b hb;
          exact Filter.mem_of_superset ( hb j hj ) ( Set.Ico_subset_Ico hi le_rfl );
      apply h_not_eq;
      rw [ â† h_inf_eq, TopologicalSpace.nhds_generateFrom ];
      refine' le_antisymm _ _;
      Â· refine' le_iInf fun i => le_iInf fun j => le_iInf fun hij => _;
        exact iInfâ‚‚_le _ âŸ¨ âŸ¨ hij.1, hij.2 âŸ©, i, j, rfl âŸ©;
      Â· refine' le_iInfâ‚‚ fun s hs => _;
        rcases hs with âŸ¨ has, âŸ¨ i, j, rfl âŸ© âŸ©;
        refine' iInf_le_of_le i ( iInf_le_of_le j ( iInf_le_of_le âŸ¨ has.1, has.2 âŸ© le_rfl ) )

theorem nhdsWithin_Ici_eq_iInf_Ico (a : Î¹) : ğ“[â‰¥] a = â¨… b > a, ğ“Ÿ (Set.Ico a b) := by
  simp +decide [ nhdsWithin, Filter.mem_inf_principal ];
  -- Since these two sets are equal, their neighborhoods are also equal.
  have h_eq : nhds a âŠ“ ğ“Ÿ (Set.Ici a) = â¨… b > a, ğ“Ÿ (Set.Ico a b) := by
    have h1 : nhds a âŠ“ ğ“Ÿ (Set.Ici a) = (â¨… c < a, ğ“Ÿ (Set.Ioi c)) âŠ“ (â¨… b > a, ğ“Ÿ (Set.Iio b)) âŠ“ ğ“Ÿ (Set.Ici a) := by
      simp +zetaDelta at *;
      rw [ nhds_eq_order ];
      rfl
    simp +decide [ h1, iInf_inf_eq, Set.Ico ];
    refine' le_antisymm _ _ <;> simp +decide [ Filter.le_def ];
    Â· intro b hb x hx;
      simp_all +decide [ Set.subset_def, Filter.mem_inf_principal ];
      refine' Filter.mem_inf_of_inter _ _ _;
      exact Set.univ;
      exact Set.Iio b;
      Â· exact Filter.univ_mem;
      Â· exact Filter.mem_iInf_of_mem b ( Filter.mem_iInf_of_mem hb ( Filter.mem_principal_self _ ) );
      Â· exact fun y hy => fun hy' => hx y hy' hy.2;
    Â· refine' âŸ¨ âŸ¨ _, _ âŸ©, _ âŸ©;
      Â· -- For any $i < a$, and any $x$ that contains $(i, a)$, $x$ must contain $[a, b)$ for any $b > a$. Therefore, $x$ is in the infimum of these filters.
        intros i hi x hx
        have h_contain : âˆ€ b > a, Set.Ico a b âŠ† x := by
          exact fun b hb => fun y hy => hx <| lt_of_lt_of_le hi hy.1;
        exact Filter.mem_iInf_of_mem ( Classical.choose ( NoMaxOrder.exists_gt a ) ) ( Filter.mem_iInf_of_mem ( Classical.choose_spec ( NoMaxOrder.exists_gt a ) ) ( Filter.mem_principal.mpr ( by rintro y âŸ¨ hyâ‚, hyâ‚‚ âŸ© ; exact h_contain _ ( Classical.choose_spec ( NoMaxOrder.exists_gt a ) ) âŸ¨ hyâ‚, hyâ‚‚ âŸ© ) ) );
      Â· bound;
        refine' Filter.mem_iInf_of_mem i ( Filter.mem_iInf_of_mem i_1 _ );
        exact Filter.mem_principal.mpr ( fun x hx => a_1 hx.2 );
      Â· intro x hx;
        refine' Filter.mem_iInf_of_mem ( Classical.choose ( NoMaxOrder.exists_gt a ) ) ( Filter.mem_iInf_of_mem ( Classical.choose_spec ( NoMaxOrder.exists_gt a ) ) _ );
        exact Filter.mem_principal.mpr fun y hy => hx hy.1;
  exact h_eq

theorem nhds_lowerLimit_eq_nhdsWithin_Ici (a : Î¹) :
    @nhds Î¹ (TopologicalSpace.generateFrom {s | âˆƒ i j, s = Set.Ico i j}) a = ğ“[â‰¥] a := by
  rw [nhds_lowerLimit_eq, nhdsWithin_Ici_eq_iInf_Ico]

end AristotleLemmas

theorem continuous_of_rightContinuous [NoMaxOrder Î¹] (hf_cont : âˆ€ a, ContinuousWithinAt f (Set.Ioi a) a) :
    @Continuous Î¹ Î± (TopologicalSpace.generateFrom {s : Set Î¹ | âˆƒ (i j : Î¹), s = Set.Ico i j})
      hÎ± f := by
  -- To prove continuity, it suffices to show that the neighborhood filter in the lower limit topology is equal to the neighborhood filter within [a, âˆ) in the order topology.
  have h_neighborhood : âˆ€ a : Î¹, @nhds Î¹ (TopologicalSpace.generateFrom {s | âˆƒ i j, s = Set.Ico i j}) a = ğ“[â‰¥] a := by
    intro a; rw [ nhds_lowerLimit_eq_nhdsWithin_Ici ] ;
  -- Since Set.Ici a = insert a (Set.Ioi a), and continuity within insert a s at a is equivalent to continuity within s at a (by `continuousWithinAt_insert_self`), this is equivalent to `ContinuousWithinAt f (Set.Ioi a) a`.
  have h_cont_eq : âˆ€ a : Î¹, ContinuousWithinAt f (Set.Ici a) a â†” ContinuousWithinAt f (Set.Ioi a) a := by
    exact fun a â†¦ Iff.symm continuousWithinAt_Ioi_iff_Ici;
  simp_all +decide [ ContinuousWithinAt ];
  simp_all +decide [ continuous_iff_continuousAt, ContinuousAt ]
